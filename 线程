ios  多线程  ； 线程的生命周期     NSThread    GCD   NSOperation  的使用总结 
前言  
我负责努力  其他的交给运气 
正文  
闲暇之余   把线程问题整理一下   感觉可能会有点长 所以自己分一下章节  我将按照以下几个小节来展开描述 
多线程的基本概念  
线程的状态与生命周期  
多线程的对比    pthread  Nsthread    gcd   nsoperation  
NSThread 的使用  
GCD 的理解与使用 
NSOperation 的理解与使用 

多线程的基本概念

 进程   ： 是计算机中的程序关于某数据集合上的一次运动活动  是系统进行资源分配和调度的基本单位  是操作系统结构的基础 
 在当代面向线程设计的计算机结构中  进程是线程的容器  
 简单来说  进程了可以看做app 执行的一个实例  一个进程可以拥有多个线程 线程与进程的一个主要区别是  同一个进程内的多个线程会共享部分状态  多个线程可以读写
 同一块内存   一个线程无法访问另一个线程  
 
 线程 是操作系统能够进行运算调度的最小单位   它包含在进程之中  是进程中的实际运作单位   一条线程指的是进程中一个单一顺序的控制流  一个进程中最少有一个线程 
 也可以有多个线程  每个线程执行不同的任务 
 
 主线程  当一个程序启动时  就有一个进程被操作系统创建于此同时一个线程也立刻运行  该线程通常叫做程序的主线程   因为它是程序开始时执行的 如果你需要再创建
 线程那么创建的线程就是这个主线程的子线程  主线程的重要性体现在两方面  1  是产生其他子线程的线程   2  通常他必须最后完成执行比如执行各种关闭动作  
 
 
 多线程   在同一时刻  一个cpu  只能处理1条线程  但cpu 可以在多条线程之间快速的切换  只要切换的足够快  就造成了多线程一同执行的假象  
 而我们运用多线程的目的在于  避免阻塞主线程   多线程是通过提高资源使用率来提高系统总体的效率 
 
 最后做个形象的比喻       一个运行的app 我们可以看做是奔跑的火车   而一个火车最少要有一个火车头  主线程负责程序的运行  且一个进程至少包含一个线程
 可以有多节车厢   多线程每一节车厢 可以看做是子线程   可一执行不同的任务 
 
  线程的状态和生命周期  
  如下图所示  
  
  线程的生命周期分为 新建就绪  运行  阻塞   死亡  
  
  新建  就绪  运行  阻塞  死亡 
  
  线程状态图  
  新建  实例化线程对象  
  就绪  向线程对象发送start 消息    线程对象加入可调度线程池等待cpu 调度  
  运行  cpu  负责调度科调度的线程池中线程的执行  线程执行完成之前状态可能会在就绪和运行之间来回切换  就绪和运行之间的状态变化由cpu 负责程序员不能干预 
  阻塞 当满足某个预定条件是时   可以使用休眠或锁 阻塞线程执行  sleepForTimeinterval  休眠指定时长  sleepuntildate  休眠到指定日期  @synchronizeds
  (互斥锁等各种锁 )
  死亡   正常死亡 线程执行完毕   非正常死亡 当满足某个条件后  在线程内部中止执行  在主线程中止线程对象 
   NSthread  exit 一旦强行终止线程 后续的所有代码都不会被执行 
   thread cancel  取消   并不会直接取消线程  只是给线程对象添加isCanCelled 标记 
   
   三  多线程的对比   pthread    nsthread  Gcd  NSoperation 
   
  相比较 pthread  和NSthread    Gcd 和 NsOpertaion  更常用一些   所以说一下gcd  和 NSOperation 
  
  1 gcd  是一套c 语言api   执行和操作简单高效   因此NSOperation  底层也通过GCD 实现  这时他们之间最本质的区别 
  因此如果希望自定义任务  建议使用NSoperation 
  
  2 依赖关系  NSoperation 可以设置操作之间的依赖可以跨队列设置gcd  无法设置依赖关系  不过可以通过同步来实现这种效果 
  3 kvo  键值对观察  NSOperation 容易判断操作当前的状态  是否执行 是否取消等  对此gcd 无法通过kvo进行判断 
  4 优先级 NSOperation  可以设置自身的优先级 但是优先级高的 不一定执行  gcd 只能设置队列的优先级  如果要区分block 任务的优先级需要很复杂的代码才能实现
  5 继承 NSOperation 是一个抽象类 实际开发中常用的是它的两个子类  NSinvocationOperation 和 NsBlockOperation 同样我们可以自定义NSoperation Gcd
  执行任务可以自由组装  没有继承那么高的代码复用  
  
  6 效率 直接使用gcd 效率确实会更高效   NSOperation 会多一点开销 但是通过NSOperation 可以获得依赖  优先级 继承键值对观察这些优势  相对与多那么一点
  开销很划算  鱼和熊掌不可兼得  取舍在于开发者自己
  7 可以随时取消准备执行的任务  已经在执行的不能取消  gcd 没法停止已经加入queue 的block  虽然也能实现但需要很复杂的代码 
  
  基于gcd  简单高效  更强的执行能力  操作不太复杂的时候 优先选用gcd  而比较复杂的任务可以自己通过NSOperation 实现 
  
  
  
  
   
   
   
   
   
   
   
   
  
  
  
  
 
 

